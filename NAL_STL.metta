;; UTILITIES ;;

(= (TupleConcat $Ev1 $Ev2) 
   (collapse (superpose ((superpose $Ev1)
                         (superpose $Ev2)))))

(= (any $Z)
   (not (== () $Z)))

(= (range $K $N)
   (If (< $K $N)
       (TupleConcat ($K) (range (+ $K 1) $N)) ()))

(= (firstTrue $Ïˆ from $a to $b)
   (If (> $a $b)
       none
       (If ($Ïˆ $a)
           $a
           (firstTrue $Ïˆ from (+ 1 $a) to $b))))

;; PROPOSITIONAL LOGIC ;;

(= (âˆ§ $P $Q)
   (and $P $Q))

(= (v $P $Q)
   (or $P $Q))

(= (Â¬ $P)
   (not $P))

(= (âŸ¹ $P $Q)
   (v ((Â¬ $P) $Q)))

(= (âŸº $P $Q)
   (âˆ§ ($P âŸ¹ $Q) ($Q âŸ¹ $P)))

;; QUANTIFIED PREDICATES OVER INTERVALS ;;

(= (âˆ€x $Ï• from $a to $b)
   (If (> $a $b)
       True
       (and ($Ï• $a) (âˆ€x $Ï• from (+ $a 1) to $b))))

(= (âˆƒx $Ï• from $a to $b)
   (If (> $a $b)
       False
       (or ($Ï• $a) (âˆƒx $Ï• from (+ 1 $a) to $b))))

;count true
(= (Tx $Ï• from $a to $b)
   (If (> $a $b)
       ()
       (let $rest (Tx $Ï• from (+ 1 $a) to $b)
            (If ($Ï• $a)
                (TupleConcat ($a) $rest)
                $rest))))

(= (Fx $Ï• from $a to $b)
   (If (> $a $b)
       ()
       (let $rest (Fx $Ï• from (+ 1 $a) to $b)
            (If (not ($Ï• $a))
                (TupleConcat ($a) $rest)
                $rest))))

;; SIGNAL TEMPORAL LOGIC ;;

;globally
(= (â–¡ $Ï• from $a to $b at $t)
   (âˆ€x $Ï• from (+ $t $a) to (+ $t $b)))

;finally
(= (â—Š $Ï• from $a to $b at $t)
   (âˆƒx $Ï• from (+ $t $a) to (+ $t $b)))

;until
(= (ğ’° $Ï• $Ïˆ from $a to $b at $t)
   (any (collapse (let* (($I (range (+ $t $a) (+ $t $b)))
                         ($y (superpose $I)))
                        (If (and ($Ïˆ $y) (âˆ€x $Ï• from $t to $y)) thing)))))

;; SIGNAL TEMPORAL NAL

; Temporal ops with NAL truth value

(= (Truth_w2TV $wp $w)
   ((/ $wp $w)
    (/ $w (+ $w 1))))

;globally
(= (â–¡TV $Ï• from $a to $b at $t)
   ((Tx $Ï• from (+ $t $a) to (+ $t $b))
    (range (+ $t $a) (+ 1 (+ $t $b)))))

;finally
(= (â—ŠTV $Ï• from $a to $b at $t)
   (let $ival (range (+ $t $a) (+ (+ $t $b) 1))
        (If (â—Š $Ï• from $a to $b at $t)
            ($ival ())
            (range (+ $t $a) (+ 1 (+ $t $b))))))

;until
(= (ğ’°TV $Ï• $Ïˆ from $a to $b at $t)
   (let $ts (firstTrue $Ïˆ from (+ $t $a) to (+ $t $b))
        (If (== $ts none)
            (() (range $t (+ (+ $t $b) 1))) ;all false from t till t+b
            ((TupleConcat (range (+ 1 $ts) (+ (+ $t $b) 1)) ;true from ts+1 to t+b
                          (Tx $Ï• from $t to $ts)) ;points where Ï• holds within t and ts-1
             (range $t (+ 1 (+ $t $b))))))) ;points where Ï• does not hold within t and ts




;; EXAMPLE ;;

(= (x $t) $t)
(= (Ï• $t) (< (x $t) 10))
(= (Ïˆ $t) (< (x $t) 20))

;!(â–¡ Ï• from 1 to 10 at 0)
;!(let* (($I (range 1 6))
;        ($t (superpose $I)))
;       (â–¡ Ï• from 1 to 5 at $t))
;!(â–¡ Ï• from 1 to 10 at 0)
;!(ğ’° Ï• Ïˆ from 0 to 13 at 5)
;!(â–¡ Ï• from 1 to 10 at 0)

;!(â–¡TV Ï• from 1 to 10 at 0)
;!(â—ŠTV Ï• from 1 to 10 at 0)
;!(ğ’°TV Ï• Ïˆ from 1 to 10 at 0)

(= (âˆ§TV ($pp1 $ptotal1) ($pp2 $ptotal2))
   ((collapse (intersection (superpose $pp1) (superpose $pp2)))
    (unique (union $ptotal1 $ptotal2))))

(= (TupleCount $tuple) (If (== $tuple ()) 0 (+ 1 (TupleCount (cdr-atom $tuple)))))

(= (Truth_fromSets ($P $T))
   (Truth_w2TV (TupleCount $P) (TupleCount $T)))

(= (ğ’°TV_nested_helper ($Ï•L $Ï•) $Ïˆ from $a to $b at $t)
   (let $ts (firstTrue $Ïˆ from (+ $t $a) to (+ $t $b)) ;last component ( $Ïˆ )
        (If (not (== $ts none))
            (If (== $Ï•L ())
                (TupleConcat (range (+ 1 $ts) (+ (+ $t $b) 1)) ;ts onwards plus
                             (Tx $Ï• from (+ $t $a) to (+ $t $ts)))    ;prior points where $Ï• holds
                (ğ’°TV_nested_helper $Ï•L $Ï• from $a to $ts at $t)))))

(= (ğ’°TV_nested ($Ï•L $Ï•) $Ïˆ from $a to $b at $t)
   ((ğ’°TV_nested_helper ($Ï•L $Ï•) $Ïˆ from $a to $b at $t)
    (range $t (+ $t (+ 1 $b)))))

;!(Truth_fromSets (â–¡TV safe from 0 to 179 at 0))
;!(Truth_fromSets (ğ’°TV_nested ((() A) B) C from 0 to 179 at 0))
;!(Truth_fromSets (âˆ§TV (â–¡TV safe from 0 to 179 at 0) (ğ’°TV_nested ((() A) B) C from 0 to 179 at 0)))

!(â–¡TV safe from 0 to 179 at 0)
!(ğ’°TV_nested ((() A) B) C from 0 to 179 at 0)

!(Truth_fromSets (âˆ§TV (â–¡TV safe from 0 to 179 at 0)
                      (ğ’°TV_nested ((() A) B) C from 0 to 179 at 0)))

;!(Truth_fromSets (âˆ§TV (ğ’°TV A B from 0 to 179 at 0) (ğ’°TV B C from 0 to 179 at 0)))
;!(ğ’°TV B C from 0 to 179 at 0)
;!(Truth_fromSets (âˆ§TV (â–¡TV safe from 0 to 179 at 0)
;                      (âˆ§TV (ğ’°TV A B from 0 to 179 at 0) (ğ’°TV B C from 0 to 179 at 0))))

;!(ğ’°TV safeA safeB from 0 to 9 at 0)
;!(â–¡TV safeA from 0 to 9 at 0)
;!(â–¡TV safeB from 0 to 9 at 0)

;!(âˆ§TV (â–¡TV A from 0 to 179 at 0) (â–¡TV B from 0 to 179 at 0))
;!(âˆ§TV (ğ’°TV A B from 0 to 179 at 0) (â–¡TV safe from 0 to 9 at 0))

;todo in mettamorph
;(= (intersection $a $a) $a)

;!(ğ’°TV safeA safeB from 0 to 9 at 0)
;;safeB is fulfilled in t=6 for first time, however A does not hold so safeA does not
;;meaning 0, 2, 4 is positive evidence (safe and A), and 7, 8, 9 despite 7 and 9 not being safe
;!(âˆ§TV (ğ’°TV A B from 0 to 9 at 0) (â–¡TV safe from 0 to 9 at 0))
;;here 0, 2, 4 is positive evidence, and 8.
;;Additionally 6 is positive evidence, as 6 is safe, and B is fulfilled at 5 already

;(= (BC) (ğ’° B C from 0 to 179 at 0))
;(= (nestedABC) (ğ’° A nestedBC from 0 to 179 at 0))

;!(Truth_fromSets (ğ’°TV safeA safeB from 0 to 9 at 0))
;!(âˆ§TV (â–¡TV safe from 0 to 179 at 0) (âˆ§TV (ğ’°TV A B from 0 to 179 at 0) (ğ’°TV B C from 0 to 179 at 0)))
;!(Truth_fromSets (âˆ§TV (â–¡TV safe from 0 to 179 at 0) (âˆ§TV (ğ’°TV A B from 0 to 179 at 0) (ğ’°TV B C from 0 to 179 at 0))))

;!(Truth_fromSets (âˆ§TV (â–¡TV safe from 0 to 179 at 0) (âˆ§TV (ğ’°TV A B from 0 to 179 at 0) (ğ’°TV B C from 0 to 179 at 0))))

